<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://aceysx.github.io</id>
    <title>Acey</title>
    <updated>2019-09-10T05:46:24.297Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://aceysx.github.io"/>
    <link rel="self" href="https://aceysx.github.io/atom.xml"/>
    <subtitle>终身学习实践者</subtitle>
    <logo>https://aceysx.github.io/images/avatar.png</logo>
    <icon>https://aceysx.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Acey</rights>
    <entry>
        <title type="html"><![CDATA[「OpenJdk-11 源码-系列」 ArrayList]]></title>
        <id>https://aceysx.github.io/post/openjdk-11-yuan-ma-xi-lie-arraylist</id>
        <link href="https://aceysx.github.io/post/openjdk-11-yuan-ma-xi-lie-arraylist">
        </link>
        <updated>2019-09-08T14:42:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="arraylist-定义">ArrayList 定义</h2>
<pre><code class="language-java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
	implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable{
	
	private static final int DEFAULT_CAPACITY = 10;
	private static final Object[] EMPTY_ELEMENTDATA = {};
	private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
	transient Object[] elementData;
	private int size;
}
</code></pre>
<p>首先可以看到<code>ArrayList</code>继承了<code>AbstractList</code>并实现了<code>List</code>，也就是说<code>ArrayList</code>是一个数组队列，拥有了基本的增删改查，遍历的操作。</p>
<p>同时实现了</p>
<ul>
<li><code>Cloneable</code>接口，即可以被<code>clone</code></li>
<li><code>Serializable</code>接口，意味着可以被<a href="https://juejin.im/post/5d6d4107e51d453b5f1a04dc">序列化</a></li>
<li><code>RandomAccess</code>接口，<code>RandomAccess</code>接口是一个空的接口，和<code>Serializable</code>接口一样，也是作为一个标识，即可以快速访问，对于<code>ArrayList</code>来说，就是可以通过下标来访问元素。而<code>LinkedList</code>就没有实现这*个接口。</li>
</ul>
<h4 id="default_capacity-和-size-的关系"><strong>DEFAULT_CAPACITY 和 size 的关系</strong></h4>
<p>根据官方注解知道，<code>DEFAULT_CAPACITY</code>是数组总空间大小，而<code>size</code>是数组的当前的容量的大小。举个例子来说，一个可以装1L水的杯子，那么<code>DEFAULT_CAPACITY</code>就是1L，我们现在往杯子里倒入了0.5L水，那么<code>size</code>就是0.5L。当然在这，<code>DEFAULT_CAPACITY</code>的默认值是10，当<code>size</code>&gt;10的时候，会进行扩容。</p>
<h4 id="为撒-elementdata-需要-transient-进行修饰"><strong>为撒 elementData 需要 transient 进行修饰</strong></h4>
<p>刚才我们讲到<code>ArrayList</code>内部其实就是用了一个<code>Object[]</code>来进行维护数据，那既然我们已经实现了<code>Serializable</code>接口，那为撒还要用<code>transient</code>来修饰<code>elementData</code>呢？来看看序列化/反序列化的代码</p>
<pre><code class="language-java"> 	private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {

        // Read in size, and any hidden stuff
        s.defaultReadObject();

        // Read in capacity
        s.readInt(); // ignored

        if (size &gt; 0) {
            // like clone(), allocate array based upon size not capacity
            SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size);
            Object[] elements = new Object[size];

            // Read in all elements in the proper order.
            for (int i = 0; i &lt; size; i++) {
                elements[i] = s.readObject();
            }

            elementData = elements;
        } else if (size == 0) {
            elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new java.io.InvalidObjectException(&quot;Invalid size: &quot; + size);
        }
    }

	private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException {
        // Write out element count, and any hidden stuff
        int expectedModCount = modCount;
        s.defaultWriteObject();

        // Write out size as capacity for behavioral compatibility with clone()
        s.writeInt(size);

        // Write out all elements in the proper order.
        for (int i=0; i&lt;size; i++) {
            s.writeObject(elementData[i]);
        }

        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
    }
</code></pre>
<p><code>ArrayList</code>在序列化的时候会调用<code>writeObject</code>方法，将数组的<code>size</code>和<code>elementData</code>写入<code>ObjectOutputStream</code>，</p>
<p>在反序列化时调用<code>readObject</code>，从<code>ObjectInputStream</code>获取<code>size</code>和<code>elementData</code>，再恢复到<code>elementData</code>.</p>
<p>这样就可以很好的节省空间和时间。因为<code>elementData</code>整个的大小是<code>CAPACITY</code>，一般情况下都会预留一些容量，我们真正需要序列化/反序列化的只是当前存入的数据。</p>
<h2 id="构造方法">构造方法</h2>
<h4 id="无参构造方法">无参构造方法</h4>
<pre><code class="language-java">
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }

    public ArrayList(int initialCapacity) {
        if (initialCapacity &gt; 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        }
    }

	 public ArrayList(Collection&lt;? extends E&gt; c) {
        elementData = c.toArray();
        if ((size = elementData.length) != 0) {
            if (elementData.getClass() != Object[].class)
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // replace with empty array.
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }
</code></pre>
<p>第一个空参构造函数，会默认将<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>的引用传入<code>elementData</code>。在第一次添加元素的时候会扩容一个容量为10的数组。</p>
<p>第二个指定初始化的 <code>capacity</code>来创建 <code>elementData</code>, 一般推荐使用这种方式来创建<code>ArrayList</code>，减少扩容带来的内存开销。</p>
<p>第三个则是传入一个<code>Collection</code>来创建<code>elementData</code></p>
<h2 id="添加">添加</h2>
<h4 id="adde-element">add(E element)</h4>
<p>添加方法有三个重载方法，最终都会调用下面这个<code>add</code>方法</p>
<pre><code class="language-java">    private void add(E e, Object[] elementData, int s) {
        if (s == elementData.length)
            elementData = grow();
        elementData[s] = e;
        size = s + 1;
    }
    private Object[] grow() {
        return grow(size + 1);
    }
    private Object[] grow(int minCapacity) {
        return elementData = Arrays.copyOf(elementData,
                                           newCapacity(minCapacity));
    }
	private int newCapacity(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 每次扩容1.5倍
        //如果扩容后的capcity的大小等于或小于mincapacity，且如果是使用空参构造器初始化的，那么就返回Math.max(DEFAULT_CAPACITY, minCapacity)，否则返回 minCapacity（if minCapacity &gt; 0)
        if (newCapacity - minCapacity &lt;= 0) {
            if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // 使用空参构造函数elementData=DEFAULTCAPACITY_EMPTY_ELEMENTDATA
                return Math.max(DEFAULT_CAPACITY, minCapacity);
            if (minCapacity &lt; 0) // overflow
                throw new OutOfMemoryError();
            return minCapacity;
        }
        return (newCapacity - MAX_ARRAY_SIZE &lt;= 0)
            ? newCapacity
            : hugeCapacity(minCapacity);
    }	
</code></pre>
<p>在第一个方法中，<code>e</code>是指当前<code>add</code>的元素，<code>s</code>指当前<code>arrList</code>的size。可以发现，当<code>size</code>的大小和<code>elementData</code>的长度相等时，才会进行扩容，即调用<code>grow</code>，从<code>newCapacity</code>方法中可以发现，每次扩容会是当前<code>size</code>(即 <code>elementData.length</code>)的1.5倍。</p>
<h4 id="addint-index-e-element">add(int index, E element)</h4>
<pre><code class="language-java"> public void add(int index, E element) {
        rangeCheckForAdd(index);
        modCount++;
        final int s;
        Object[] elementData;
        if ((s = size) == (elementData = this.elementData).length)
            elementData = grow();
        System.arraycopy(elementData, index,
                         elementData, index + 1,
                         s - index);
        elementData[index] = element;
        size = s + 1;
    }
</code></pre>
<p>在指定下标条件元素的步骤</p>
<ol>
<li>检查<code>index</code>，如果<code>index</code>小于0，或者大于<code>size</code>，那么会抛出<code>IndexOutOfBoundsException</code>异常</li>
<li><code>modCount++</code>，后续会介绍用处</li>
<li>判断当前<code>arrayList</code>的<code>size</code>和当前<code>elementData</code>的长度是否相等，如果相当那么先进行扩容</li>
<li><code>System.arraycopy</code>进行复制，把<code>index</code>这个下标空出来</li>
<li>赋值</li>
</ol>
<h2 id="删除">删除</h2>
<h4 id="removeint-index">remove(int index)</h4>
<pre><code class="language-java">    public E remove(int index) {
        Objects.checkIndex(index, size);
        final Object[] es = elementData;

        @SuppressWarnings(&quot;unchecked&quot;) E oldValue = (E) es[index];
        fastRemove(es, index);

        return oldValue;
    }
    private void fastRemove(Object[] es, int i) {
        modCount++;
        final int newSize;
        if ((newSize = size - 1) &gt; i)
            System.arraycopy(es, i + 1, es, i, newSize - i);
        es[size = newSize] = null;
    }
</code></pre>
<p>对于<code>remove(int index)</code>源码就比较简单了，唯一需要注意的就是在<code>fastRemove</code>中的判断，如果需要删除的是数组的最后一个元素，那么直接将最后一个元素设置为<code>null</code>，否则进行<code>arraycopy</code>，将<code>index</code>的值覆盖掉。</p>
<h2 id="其它">其它</h2>
<h3 id="fail-fast-机制">Fail-Fast 机制</h3>
<p>前面我们经常看到<code>modCount++</code>的操作，那么为什么要加这个呢？其实当每次对数组进行操作（修改）的时候，都会进行<code>modCount++</code>，这样做是为了记录修改次数。</p>
<p>我们知道 <code>ArrayList</code> 不是线程安全的，因此如果在使用迭代器的过程中如果有其他线程修改（新增/删除）了<code>arrayList</code>的数据(或当前线程在遍历的过程中对数据进行修改)，那么将抛出<code>ConcurrentModificationException</code>，这就是所谓fail-fast策略。</p>
<p>在每次进行遍历的时候，会先将<code>modCount</code>赋值给<code>expectedCount</code>，在迭代过程中，进行判断，如果它们不相等，则说明<code>arrayList</code>的数据已经被修改，抛出异常。</p>
<h4 id="arrayscopyof-方法和-systemarraycopy-方法的区别">Arrays.copyOf 方法和 System.arraycopy 方法的区别？</h4>
<p><code>Arrays.copyOf(T[], int length)</code> 方法是 <code>Arrays</code> 工具类中用来进行任意类型数组赋值，并使数组具有指定长度的方法，<code>ArrayList</code> 中用这个方法来实现 <code>elementData</code> 数组的元素移动。但实际上 <code>Arrays.copyOf</code> 方法最终调用的是 <code>System.arraycopy(U[], int srcPos, T[], desPos, int length)</code> 方法，这个方法是一个<code>native</code>方法</p>
<pre><code class="language-java">    public static native void arraycopy(Object src,  int  srcPos,
                                        Object dest, int destPos,
                                        int length);
</code></pre>
<ul>
<li>src 表示的是原始数组（源数组）</li>
<li>dest 表示的是存放拷贝值的数组（目标数组）</li>
<li>srcPos 是指原始数组中的起始位置（从原始数组的哪个位置开始拷贝）</li>
<li>desPos 是指存放拷贝值的数组拷贝起始位置（从目标数组的哪个位置插入这些拷贝的值）</li>
<li>length 表示要拷贝的元素数量（要从原始数组中拷贝多少个）。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[「OpenJdk-11 源码-系列」AbstractStringBuilder,StringBuilder,StringBuffer]]></title>
        <id>https://aceysx.github.io/post/openjdk-11-yuan-ma-xi-lie-abstractstringbuilderstringbuilderstringbuffer</id>
        <link href="https://aceysx.github.io/post/openjdk-11-yuan-ma-xi-lie-abstractstringbuilderstringbuilderstringbuffer">
        </link>
        <updated>2019-09-05T15:33:13.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="abstractstringbuilder">AbstractStringBuilder</h2>
<p><code>AbstracStringBuilder</code>是<code>StringBuilder</code> 和 <code>StringBuffer</code> 的父类。前面我们讲到<code>String</code>是一个不可变的字符串。而<code>StringBuilder</code> 和 <code>StringBuffer</code> 则是对<code>String</code>的一个补充，它们是可变的。先来看<code>AbstractStringBuilder</code>的定义</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="abstractstringbuilder">AbstractStringBuilder</h2>
<p><code>AbstracStringBuilder</code>是<code>StringBuilder</code> 和 <code>StringBuffer</code> 的父类。前面我们讲到<code>String</code>是一个不可变的字符串。而<code>StringBuilder</code> 和 <code>StringBuffer</code> 则是对<code>String</code>的一个补充，它们是可变的。先来看<code>AbstractStringBuilder</code>的定义</p>
<!-- more -->
<h3 id="定义">定义</h3>
<pre><code class="language-java">abstract class AbstractStringBuilder implements Appendable, CharSequence {
    char[] value;
	int count;
	AbstractStringBuilder() {
	}
	AbstractStringBuilder(int capacity) {
    	value = new char[capacity];
	}
}
</code></pre>
<p>从类名上就可以看出来它是一个抽象方法。并且实现了<code>Appendable</code>以及<code>Appendable</code>接口中的<code>append</code>方法。使用了<code>char[]</code>来保存值，而两个构造函数也是子类所必须要实现的，用于初始化 <code>char[]</code>的大小。</p>
<h3 id="扩容">扩容</h3>
<pre><code class="language-java">	public void ensureCapacity(int minimumCapacity) {
        if (minimumCapacity &gt; 0)
            ensureCapacityInternal(minimumCapacity);
    }

    private void ensureCapacityInternal(int minimumCapacity) {
        // overflow-conscious code
        if (minimumCapacity - value.length &gt; 0) {
            value = Arrays.copyOf(value,
                    newCapacity(minimumCapacity));
        }
    }
    private int newCapacity(int minCapacity) {
        // overflow-conscious code
        int newCapacity = (value.length &lt;&lt; 1) + 2;
        if (newCapacity - minCapacity &lt; 0) {
            newCapacity = minCapacity;
        }
        return (newCapacity &lt;= 0 || MAX_ARRAY_SIZE - newCapacity &lt; 0)
            ? hugeCapacity(minCapacity)
            : newCapacity;
    }

    private int hugeCapacity(int minCapacity) {
        if (Integer.MAX_VALUE - minCapacity &lt; 0) { // overflow
            throw new OutOfMemoryError();
        }
        return (minCapacity &gt; MAX_ARRAY_SIZE)
            ? minCapacity : MAX_ARRAY_SIZE;
    } 
</code></pre>
<p>对于扩容，需要确保传入的<code>capacity</code>大于目前的<code>value</code>的长度，且小于<code>Integer.MAX_VALUE</code>（0x7fffffff）。在这个方法中首先把容量扩大为<strong>原来的容量乘2加2</strong>，如果此时仍小于指定的容量，那么就把新的容量设为<code>minCapacity</code>。然后判断是否溢出，如果溢出了，把容量设为<code>MAX_ARRAY_SIZE（Integer.MAX_VALUE-8）</code></p>
<h3 id="添加">添加</h3>
<pre><code class="language-java">    public AbstractStringBuilder append(String str) {
        if (str == null)
            return appendNull();
        int len = str.length();
        ensureCapacityInternal(count + len);
        str.getChars(0, len, value, count);
        count += len;
        return this;
    }	

	//String.class
	public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) {
        if (srcBegin &lt; 0) {
            throw new StringIndexOutOfBoundsException(srcBegin);
        }
        if (srcEnd &gt; value.length) {
            throw new StringIndexOutOfBoundsException(srcEnd);
        }
        if (srcBegin &gt; srcEnd) {
            throw new StringIndexOutOfBoundsException(srcEnd - srcBegin);
        }
        System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);
    }
</code></pre>
<p>对于 <code>append</code> 方法有很多重载。对于每种重载方法的内部实现大概可以分为下面几步：</p>
<ol>
<li>确保 <code>append</code>的值为有效的。如果是字符串，那么值如果为 <code>null</code>，则会<code>append</code>一个<code>null</code>字符串，如果是<code>long</code>或<code>int</code>的值是小于最小值，那么会<code>append</code>一个固定值</li>
<li>扩容当前值。<code>ensureCapacityInternal</code>方法会将当前的<code>char[] value</code>值复制到一个新的<code>char[] value</code>中。</li>
<li>使用 <code>getChars</code>方法将<code>append</code>的值追加到扩容的<code>value</code>后</li>
</ol>
<h2 id="stringbuilder-stringbuffer">StringBuilder &amp; StringBuffer</h2>
<p><code>StringBuilder &amp; StringBuffer</code>都实现了 <code>AbstractStringBuilder</code>接口。他们最大的不同就是<code>StringBuilder</code> 是线程不安全的，而<code>StringBuffer</code>是线程安全的。所以它们的属性和方法大致都是一样的，只是<code>StringBuffer</code>的部分方法上添加了<code>Synchronized</code>关键字来保证线程的安全。</p>
<pre><code class="language-java">	//StringBuffer.class
	public synchronized StringBuffer append(String str) { 
        toStringCache = null;
        super.append(str);
        return this;
    }
</code></pre>
<p>在<code>StringBuilder</code> 中没有<code>synchronized</code>这个关键字。对于<code>StringBuilder &amp; StringBuffer</code>的大部分都是调用的父类的方法，只是最后多了一个 <code>return this</code>。</p>
<p>上面的代码我们发现有这么一行代码<code>toStringCache=null</code>,我们来看看它的定义</p>
<pre><code class="language-java">	/**
     * A cache of the last value returned by toString. Cleared
     * whenever the StringBuffer is modified.
     */
    private transient String toStringCache;
</code></pre>
<p>根据注释，我们可以知道这个<code>toStringCache</code>是用来缓冲最后一次 <code>toString</code> 的值，如果<code>StringBuffer</code>被修改了的话，那么<code>toStringCache</code>就会被清空。接着再来看看 <code>toString</code>方法</p>
<pre><code class="language-java">	public synchronized String toString() {
        if (toStringCache == null) {
            return toStringCache =
                    isLatin1() ? StringLatin1.newString(value, 0, count)
                               : StringUTF16.newString(value, 0, count);
        }
        return new String(toStringCache);
    }
</code></pre>
<p>当调用<code>toString</code>方法的时候，如果<code>toStringCache</code>为<code>null</code>的话，那么就会调用<code>StringXXX.newString</code>方法。如果不为<code>null</code>的话，直接返回<code>toStringCache</code>。而<code>StringXXX.newString</code>的实现如下：</p>
<pre><code class="language-java">    public static String newString(byte[] val, int index, int len) {
        return new String(Arrays.copyOfRange(val, index, index + len),
                          LATIN1);
    }
</code></pre>
<p>可以发现它其实是一个copy的操作。也就是说如果<code>toStringCache</code> 存在的话，就不需要再次进行copy。直接返回<code>toStringCache</code>，这样就可以减少不必要的消耗，提升性能。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[「OpenJdk-11 源码-系列」Serializable]]></title>
        <id>https://aceysx.github.io/post/serializable</id>
        <link href="https://aceysx.github.io/post/serializable">
        </link>
        <updated>2019-09-02T14:45:08.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="serializable-是什么">Serializable 是什么</h2>
<p><code>Serializable</code> 是一种用来处理对象流的机制。对象流就是将运行时对象的状态进行流化，即转换成二进制。说白了，就是将正在运行中程序的对象的状态/内容转换成二进制进行传输，持久化的操作。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3126293-f81fb178849362a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在 Java 中，序列化是在 jdk 1.1 时引入的特性。Serializable 的定义</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="serializable-是什么">Serializable 是什么</h2>
<p><code>Serializable</code> 是一种用来处理对象流的机制。对象流就是将运行时对象的状态进行流化，即转换成二进制。说白了，就是将正在运行中程序的对象的状态/内容转换成二进制进行传输，持久化的操作。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3126293-f81fb178849362a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在 Java 中，序列化是在 jdk 1.1 时引入的特性。Serializable 的定义</p>
<!-- more -->
<pre><code class="language-java">public interface Serializable {
}
</code></pre>
<p>只有这么个接口，一旦某类实现了该接口，那么该类就有了序列化的能力，但严格来说，不一定能序列化/反序列化成功，为撒呐？先来看个 demo</p>
<h2 id="quickly-start">Quickly start</h2>
<p>举个栗子🌰，有一 <code>Women</code>类，该类有三个属性，分别是<code>age</code>,<code>weight</code>和<code>name</code>，我们来试试怎么序列/反序列化。</p>
<p><strong>先来个 Women class</strong></p>
<pre><code class="language-java">//Women.class
public class Women implements Serializable {
    private static final long serialVersionUID = 1L;
    
    private Integer age;
    private String name;
    private Float weight;

    public Women(String name, int age, float weight) {
        this.name = name;
        this.age = age;
        this.weight = weight;
    }
    
   '''
   setter/getter    
   '''
}
</code></pre>
<h3 id="序列化">序列化</h3>
<pre><code class="language-java">    public static void main(String[] args) throws IOException {
        Women women = new Women(&quot;xiao ju&quot;,18, 45.1f);
        File file = new File(&quot;xiaoju.txt&quot;);
        FileOutputStream output = new FileOutputStream(file);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(output);
        objectOutputStream.writeObject(women);
        output.close();
        objectOutputStream.close();
    }
</code></pre>
<h3 id="反序列化">反序列化</h3>
<pre><code class="language-java">    public static void main(String[] args) throws IOException, ClassNotFoundException {
        File file = new File(&quot;xiaoju.txt&quot;);
        FileInputStream input= new FileInputStream(file);
        ObjectInputStream objectInputStream = new ObjectInputStream(input);
        Women women = (Women) objectInputStream.readObject();
        input.close();
        objectInputStream.close();
    }
</code></pre>
<p>这就是序列化/反序列化的过程。可以看到我们在<code>Woemen</code>类中，不仅实现了<code>Serializable</code>接口外，还加了一个<code>serialVersionUID</code>，当然了，如果我们不手动加，那么系统也会根据当前类的结构会初始化一个<code>UID</code>，它的作用是什么呢？</p>
<p>当进行序列化的时候，<code>UID</code>会和当前对象的状态一同持续久化，在反序列化的时候，会检测当前类的<code>UID</code>是否和持久化的<code>UID</code>一致，如果一致，那么反序列化成功，否则失败。</p>
<p>如果我们没有指定<code>UID</code>的化，系统在初始化一个<code>UID</code>后，随着对象的持久化，如果我们这个时候改了该类的数据结构，那么这个类的<code>UID</code>就会发生改变（系统初始化的<code>UID</code>是根据类的数据结构算出来的），所以在反序列化的时候，就会检测到<code>UID</code>不一致，那么就会失败。所以，一般我们都会加上一个<code>UID</code>。</p>
<h3 id="那问题来了全部类都支持序列化不好嘛">那问题来了，全部类都支持序列化不好嘛？</h3>
<p>确实不好，不要你觉得，要我觉得，不是所有的类都想要序列化的，有些类是比较敏感的，比如用户类，卡号类... 对于序列化的对象的信息是很容易被破解的，不能保证其安全性。</p>
<h3 id="问题又来了我只想要序列化部分怎么办">问题又来了，我只想要序列化部分怎么办</h3>
<p>两种方式：</p>
<ol>
<li>在不想要被序列化的属性上添加<code>static</code>修饰符。前面我们说到，序列化/反序列化的都是程序正在运行中的对象的状态，而被<code>static</code>修饰的属性/方法其实是属于类的状态，不属于处于内存中的对象。</li>
<li>在不想要被序列化的属性上添加<code>transient</code>修饰，<code>transient</code>不能修饰方法/类。一旦属性被<code>transient</code>修饰，那么该属性就不会被序列/反序列化。</li>
</ol>
<h2 id="序列化规则">序列化规则</h2>
<ol>
<li>
<p>类成员</p>
<p>为了减少存储，传输空间，从提高效率，那么在进行序列化的时候，可以将不需要序列化的属性通过 <code>static</code>和<code>transient</code>关键字修饰排除掉。</p>
</li>
<li>
<p>继承关系</p>
<ul>
<li>如果父类实现了<code>Serializable</code>接口，子类序列化后，那么父类也会实现系列化</li>
<li>如果父类没有实现<code>Serializable</code>接口，子类被序列化后，父类将不会被序列化</li>
</ul>
</li>
<li>
<p>引用关系</p>
<p>如果一个类实现了序列化，并且引用了一个对象。该对象所属类实现了<code>Serializable</code>接口，那么会改对象也会被序列化，否则会抛出<code>java.io.NotSerializableExeception</code>。</p>
</li>
</ol>
<h2 id="serializable-子接口-externalizable">Serializable 子接口 Externalizable</h2>
<p>前面我们说到，实现了<code>Serializable</code>接口的类，可以将整个或部分对象的状态进行序列化/反序列化。那么如果我们想要更加定制化的序列化/反序列化一些东西的话，那么我们就需要用到<code>Externalizable</code>，比如：在序列化的时候我想保存一个时间，反序列化的时候我希望获取到这个时间，但是这个时间我不想放到类中。</p>
<pre><code class="language-java">public interface Externalizable extends java.io.Serializable {
    void writeExternal(ObjectOutput out) throws IOException;
    void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;
}

</code></pre>
<p>可以看到<code>Externalizable</code>除了实现了<code>Serializable</code>接口外，还新增了两个方法，这两个方法就是可以在序列化和反序列化的时候做一些定制的东西。还是拿<code>Women</code>来看。</p>
<pre><code class="language-java">//Women.class
public class Women implements Externalizable {
    private static final long serialVersionUID = 1L;
    
    private Integer age;
    private String name;
    private Float weight;

    public Women(String name, int age, float weight) {
        this.name = name;
        this.age = age;
        this.weight = weight;
    }
    
    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeObject(new Date());
        out.writeObject(this.name);
    }

    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        System.out.println(in.readObject());
        this.name = (String) in.readObject();
    }
    
   '''
   setter/getter    
   '''
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[「OpenJdk-11 源码-系列」String]]></title>
        <id>https://aceysx.github.io/post/openjdk-11-yuan-ma-string</id>
        <link href="https://aceysx.github.io/post/openjdk-11-yuan-ma-string">
        </link>
        <updated>2019-09-02T04:54:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="类的定义">类的定义</h2>
<p>在日常开发中，<code>String</code>可以说是最常用的类之一了，但也是最容易被忽视的类。先来看看<code>String</code>的定义</p>
<pre><code class="language-java">public final class String
 implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {

  private final char[] value; // jdk 8
  private final byte[] value; // jdk 9 使用 byte 减少空间的浪费，

  private final byte coder;
  private int hash; // Default to 0
  private static final long serialVersionUID = -6849794470754667710L;
}
</code></pre>
<p>首先，<code>String</code>被<code>final</code>所修饰，同时实现了<code>Serializable</code>，<code>Comparable</code>和<code>CharSequence</code>接口。我们一个个来看：</p>
<h4 id="为撒要用-final-修饰">为撒要用 final 修饰</h4>
<p>根据源码，我们可以看到<code>String</code>的值在内部是用一个<code>byte</code>数组<code>value</code>维护的，所以<code>value</code>是一个引用类型，对于引用类型的变量，我们往往都会十分小心，因为鬼知道在什么时候，我们就会掉进一个大坑... 更何况<code>String</code>是一个非常常用的类。所以一个非常重要的原因就是<strong>安全性</strong>，使得<code>String</code>类需要被<code>final</code>修饰，即不可变。所以对<code>String</code>类加上了<code>final</code>修饰符，防止<code>String</code>被继承，从而重写<code>value</code>。刚才说到<code>value</code>是一个引用类型，所以在<code>value</code>上也加上了<code>final</code>修饰，并且在整个类中，没有对<code>value</code>进行update的操作。所有的update操作都是会新建一个新的<code>string</code>。</p>
<h4 id="为撒实现-serializable-接口">为撒实现 Serializable 接口</h4>
<p>详情可见🔎<a href="https://juejin.im/post/5d6d4107e51d453b5f1a04dc">「OpenJdk-11 源码-系列」Serializable</a></p>
<h4 id="comparable-comparator">Comparable &amp; Comparator</h4>
<p><strong>先来看看<code>Comparable</code>接口</strong></p>
<pre><code class="language-java">public interface Comparable&lt;T&gt; {
    public int compareTo(T o);
}
</code></pre>
<p><code>Comparable</code>接口是一个排序接口，若一个类实现了该接口并重写了<code>compareTo</code>方法，就意味着这个类支持了排序。当存在一个实现了<code>Comparable</code>接口的类的集合或数组，那么该集合或数组就可以通过<code>Collections.sort / Arrays.sort</code>进行排序。</p>
<ul>
<li>当返回值为正数，那么就意味着 a &gt; b (<code>a.compareTo(b)</code>)</li>
<li>当返回值为零，那么a = b</li>
<li>当返回值为负数，那么a &lt; b</li>
</ul>
<p><strong>再来看看<code>Comparator</code> 接口</strong></p>
<pre><code class="language-java">public interface Comparator&lt;T&gt; {
    //最主要的俩方法
    int compare(T o1, T o2);
    boolean equals(Object obj);
}
</code></pre>
<p>刚才我们说到如果一个类实现了<code>Comparable</code>接口后，那么该类就有了排序的功能。但有的时候我们不想修改这个类，减少对类的侵入。那么我们就可以自定义一个类来实现<code>Comparator</code>接口。</p>
<p>总结一下，实现<code>Comparable</code>接口可以做到内部比较（即相同类之间的比较）；而实现了<code>Comparator</code>接口的类，可以使用该类对任意两个类型的对象进行比较，且无侵入性。</p>
<h2 id="属性">属性</h2>
<pre><code class="language-java">public final class String
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
    private final byte[] value;
    private final byte coder;
    private int hash; // Default to 0

}
</code></pre>
<ul>
<li>
<p>value</p>
<p><code>value</code>存储的是 <code>String</code>的内容，即当使用<code>String str = &quot;abc&quot;;</code>的时候，&quot;abc&quot;是存储在一个<code>byte</code>类型的数组中的。这在后续的构造函数中会讲解到。</p>
</li>
<li>
<p>coder</p>
<p>在JDK9中，<code>String</code>维护了这样一个新的属性<code>coder</code>，它是一个编码格式的标识，表示LATIN1或者UTF-16，String生成的时候会自动初始化这个值，如果字符串中都是能用LATIN1就能表示的就是0，否则就是UTF-16。</p>
<p>那么为什么要加这个<code>coder</code>属性呢？先说结论，可以对字符串的空间进行压缩。先看源码</p>
<pre><code class="language-java">//jdk8
    public int length() {
        return value.length;
    }
//jdk9
    static final boolean COMPACT_STRINGS;
    static {
        COMPACT_STRINGS = true; //默认开启压缩
    }    
    byte coder() {
        return COMPACT_STRINGS ? coder : UTF16;
    }
    public int length() {
        return value.length &gt;&gt; coder(); //如果coder() = 1则会右移一位
    }
</code></pre>
<p>所以，如果当我们调用<code>length</code>方法的时候，如果<code>value</code>是<code>LATIN1</code>编码的话那么就会右移一位，减少一个字节数。</p>
</li>
<li>
<p>hash</p>
<p><code>hash</code>是<code>String</code>在实例化的时候对<code>hashcode</code>的一个缓存。由于在开发中<code>String</code>会经常拿来比较，比如<code>HashMap</code>中如果<code>key</code>  是<code>String</code>类型，每次比较如果都重新计算<code>hashcode</code>的话就会很费时。</p>
</li>
</ul>
<h2 id="构造方法">构造方法</h2>
<pre><code class="language-java">    public String() {
        this.value = &quot;&quot;.value;
        this.coder = &quot;&quot;.coder;
    }
</code></pre>
<p>空参构造方法，会创建一个空的字符串序列。一般不会这么创建。</p>
<pre><code class="language-java">    //常见的几种构造方法
	public String(byte[] bytes) {
        this(bytes, 0, bytes.length);
    }
	public String(byte bytes[], String charsetName)
            throws UnsupportedEncodingException {
        this(bytes, 0, bytes.length, charsetName);
    }
	public String(byte bytes[], Charset charset) {
        this(bytes, 0, bytes.length, charset);
    }
    public String(byte bytes[], String charsetName)
            throws UnsupportedEncodingException {
        this(bytes, 0, bytes.length, charsetName);
    }
    
    public String(byte bytes[], int offset, int length, String charsetName)
            throws UnsupportedEncodingException {
        if (charsetName == null)
            throw new NullPointerException(&quot;charsetName&quot;);
        checkBoundsOffCount(offset, length, bytes.length);
        StringCoding.Result ret =
            StringCoding.decode(charsetName, bytes, offset, length);
        this.value = ret.value;
        this.coder = ret.coder;
    }
	
	public String(byte bytes[], int offset, int length, Charset charset) {
        if (charset == null)
            throw new NullPointerException(&quot;charset&quot;);
        checkBoundsOffCount(offset, length, bytes.length);
        StringCoding.Result ret =
            StringCoding.decode(charset, bytes, offset, length);
        this.value = ret.value;
        this.coder = ret.coder;
    }
</code></pre>
<p>使用字节数组来创建可以分为指定编码或默认编码（ISO-8859-1）进行编码操作。</p>
<h2 id="常用方法">常用方法</h2>
<p>比较简单，可直接查看API</p>
<h2 id="其它">其它</h2>
<h4 id="string-对-号的重载">String 对 + 号的重载</h4>
<pre><code class="language-java">String str = &quot;this is&quot;;
String str1 = str + &quot;str&quot;
</code></pre>
<p>在底层，Java 对 String 的+的支持使用的是 <code>StringBuilder</code> 以及它的<code>append</code>和<code>toString</code>方法。即：</p>
<pre><code class="language-java">String str = &quot;str&quot;;
String str1 = (new StringBuilder(String.valueOf(str))).append(&quot;str&quot;).toString();
</code></pre>
<h4 id="intern">intern</h4>
<pre><code class="language-java">public native String intern();
</code></pre>
<p>可以看到 <code>intern</code> 是被 <code>native</code>修饰，这说明该方法是由底层的C/C++进行实现的。它的作用是 如果常量池中存在当前字符串, 就会直接返回当前字符串。如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回。<strong>通过双引号声明的字符串会放入到常量池中</strong></p>
<pre><code class="language-java">String str = &quot;123&quot;;
String str1 = new String(&quot;123&quot;);
String str2 = str1.intern();
s
System.out.println(str == str1); //false
System.out.println(str == str2); // true
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[培训入门儿——指导手册]]></title>
        <id>https://aceysx.github.io/post/pei-xun-ru-men-er-zhi-dao-shou-ce</id>
        <link href="https://aceysx.github.io/post/pei-xun-ru-men-er-zhi-dao-shou-ce">
        </link>
        <updated>2019-09-02T04:35:47.000Z</updated>
        <summary type="html"><![CDATA[<p>一入培训深似海，从此各处寻套路哇。</p>
<h2 id="一-聚焦问题显价值">一 聚焦问题显价值</h2>
<h3 id="问题是什么">✨问题是什么</h3>
<p>首先，我们来思考一个问题，为什么我们要做培训or参加培训呢？对于培训师而言，他们是帮助客户解决他们所遇到的问题；而作为参加培训的学员主要是为了改善自身的不足or提高自身的能力。任何一次培训都是为了解决或改善存在的问题（人的知识、态度、能力的差距问题）。所以对于一次培训来说，第一步需要先搞清楚以下几个问题：</p>
]]></summary>
        <content type="html"><![CDATA[<p>一入培训深似海，从此各处寻套路哇。</p>
<h2 id="一-聚焦问题显价值">一 聚焦问题显价值</h2>
<h3 id="问题是什么">✨问题是什么</h3>
<p>首先，我们来思考一个问题，为什么我们要做培训or参加培训呢？对于培训师而言，他们是帮助客户解决他们所遇到的问题；而作为参加培训的学员主要是为了改善自身的不足or提高自身的能力。任何一次培训都是为了解决或改善存在的问题（人的知识、态度、能力的差距问题）。所以对于一次培训来说，第一步需要先搞清楚以下几个问题：</p>
<!-- more -->
<p><strong>1. 需求来源（客户）是谁</strong><br>
我们是在为谁解决问题？谁来和我们对接？谁来为这次培训买单？总之一定要搞清楚客户是谁。他们可能是某高层领导、业务部门或者是员工。</p>
<p><strong>2. 培训的目标是谁</strong><br>
<strong>3. 期望值是什么</strong><br>
培训前，学员是什么水平；经过培训后，希望达到什么样的高度。</p>
<p>这就是培训的价值所在，帮助<strong>客户</strong>培训<strong>目标对象</strong>，帮助这些<strong>目标对象</strong>达到<strong>客户</strong>所期望的高度。</p>
<h4 id="理清需求准确描述问题现状">理清需求，准确描述问题现状</h4>
<p>培训的目的是为了解决问题，在培训准备阶段则需要向客户收集问题，一般会采用<strong>问卷调查</strong>或<strong>当面访谈法</strong>，对与<strong>当面访谈法</strong>则应该提前准备好访谈的问题：</p>
<ul>
<li>事实性问题（客户遇到了什么问题）</li>
<li>需求性问题（对培训有哪些需求）</li>
<li>结果性问题（用什么标准来衡量培训效果）</li>
<li>探索性问题</li>
<li>确定性问题</li>
</ul>
<p>在和客户面对面访谈时，大多数情况下会出现以下问题：</p>
<ul>
<li>客户说不清楚</li>
<li>有所隐蔽</li>
<li>急于求成</li>
</ul>
<p>作为应对，可以使用 4W 大法引导客户，理清需求，who（谁的问题），what（出现了什么问题），when（问题发生的情景-时间），where（问题发生的情景-地点）。</p>
<h3 id="选定有价值的问题">✨选定有价值的问题</h3>
<p>经过第一轮，我们确定了客户的痛点是什么。接下来，又该轮到问自己几个问题了。</p>
<ol>
<li>是否可以通过培训解决</li>
<li>是否有价值</li>
<li>是否有内容专家</li>
</ol>
<p>如果这个问题是非培训影响力，比如制度、环境等非认为因素，那么就不该是培训所能解决的。其次，如果没有为客户带来任何价值，那么也不该进行培训。最后，如果有内容专家，那么可以选择定制开发or经验萃取否则则需要考虑是否要外部采购课程。<br>
<img src="https://upload-images.jianshu.io/upload_images/3126293-a6b3a7b23370b9be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="课程开发选题矩阵"></p>
<h4 id="挖掘问题背后的本质">挖掘问题背后的本质</h4>
<p>在确定该问题是可以通过培训所解决的前提下，就可以对该问题下手了，深度挖掘出现这个问题的背后的本质是什么；常用的方法有 5W法，俗称剥洋葱法、鱼骨图法，是什么原因导致了这个问题的出现，主要原因是什么，次要原因又是什么，从而帮助我们更好的制定目标 &amp; 课程。</p>
<p>在经过对问题的深度挖掘后，接下来就可以梳理制定目标；凸出课程的价值定位。往往我们可以通过一句话来描述课程开发目标：<strong>解决（谁），在（什么情景和场景下），（什么问题），达到什么结果。</strong></p>
<h2 id="二-课程开发">二 课程开发</h2>
<h3 id="萃取内部经验">✨萃取内部经验</h3>
<p>在准备开发课程之前，可以先收集内部资料，避免做一些不需要做的重复的事；其次对内容专家进行访谈，访谈之前可以准备以下问题：</p>
<ul>
<li>针对XX问题，你有哪些成功经历</li>
<li>在这些经历中，哪些是关键环境or行为</li>
<li>假如你在面对XX难题时，你会如何做</li>
<li>普通员工最容易犯错的地方在哪？如何避免</li>
</ul>
<h3 id="搭建课程结构">✨ 搭建课程结构</h3>
<p><strong>原则</strong>：不多不少不重复（对培训的目标没有帮助的内容直接舍去）<br>
<strong>常用逻辑关系</strong></p>
<ul>
<li>流程：单向&amp;循环</li>
<li>元素
<ul>
<li>根据不通的角度解决问题</li>
<li>问题归纳</li>
</ul>
</li>
<li>线索</li>
<li>关系</li>
</ul>
<h3 id="细化内容">✨细化内容</h3>
<p>**原则：**当堂可完成；当堂可检验<br>
<strong>课堂表现目标的四元素</strong></p>
<ul>
<li>Audience</li>
<li>Behavior</li>
<li>Condition</li>
<li>Degree</li>
</ul>
<p>经过培训，学员能够在XX条件下，完成XX任务，达到XX水平</p>
<h2 id="三-4c培训">三 4C培训</h2>
<p><img src="https://upload-images.jianshu.io/upload_images/3126293-9b562cbabb3f941b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自然学习模式-4MAT"></p>
<h3 id="建立联系">✨ 建立联系</h3>
<p>从培训开始，我们就应该把 C 位让给学员，因为这是一个以学员为中心的培训；那么学员的积极性则是非常重要的，其次学员还应该了解本次到培训的主题是什么，通过这次培训能获得自己想要的嘛？所以需要在开始时帮助学员建立以下几个联系：</p>
<ul>
<li>学员同学员之间的联系（建立安全感）</li>
<li>学员同主题之间的联系</li>
<li>学员同个人目标之间的联系</li>
<li>学员同学习成果之间的联系</li>
</ul>
<p>一般可以在开场活动通过游戏来建立这些联系：</p>
<ul>
<li>
<p>桌上讨论<br>
讲一个和主题有关的开放性的问题贴在墙上，给大家几分钟的时间分组讨论，简单的讨论后，让学员把讨论的结果报告给大家。</p>
</li>
<li>
<p>站在哪边<br>
将一个和主题相关的问题的并提出一种解决方案，对于学员，同意该解决方案的站在左边，不同意的站在右边。培训师这个时候就可以问学员：</p>
</li>
<li>
<p>关于队友的选择，你从中学到了什么（小组讨论）</p>
</li>
<li>
<p>是什么让你选择站在这一方</p>
</li>
<li>
<p>若要做出一个更加知情的选择，你还想要了解哪些信息</p>
</li>
</ul>
<p>最后让大家发表自己的看法</p>
<h3 id="概念">✨ 概念</h3>
<p>在开始教学时，注意以下几个原则：</p>
<ul>
<li>只教应知应会知识</li>
<li>提供组织图</li>
<li>互动式教学</li>
<li>十分钟原则（1分钟复习 ... 不要一直BB）</li>
</ul>
<p><strong>互动式教学练习：</strong><br>
在讲课中间停下来，告诉学员思考一下刚才讲过的内容；让大家把自己感觉重要的内容说出来。除非有不对的地方，否则不要打断。<br>
【可选附加练习】</p>
<ul>
<li>想一想到现在为止的学过的内容，如果必须要针对这些内容出一道测试题，你会问什么？写在卡片上（可以让大家互传卡片，进行回答）</li>
<li>对刚学的内容用一句话进行总结</li>
<li>思考如何向一名同事解释为什么你认为这个信息如此重要，记录在卡片上</li>
</ul>
<h3 id="实用练习">✨实用练习</h3>
<p>在做练习时，为了让学员都能做有效的练习，需要注意以下三点：</p>
<ul>
<li>人人积极参与</li>
<li>互相合作</li>
<li>各司其职</li>
</ul>
<p>**倚赖型活动 练习：<br>
人人都来教：两个人互相教学，一人假装完全不懂要学的这项技能，另一个人则需要向对方展示这个技能，并教会对方。</p>
<p>当然也可以让学员自己来设计游戏。</p>
<h3 id="总结">✨总结</h3>
<p>在培训结束后，一般培训师会和学员们一起举行各种感谢活动... 而对于培训来说，为了让学员更好的巩固自身所学，由于近因原则，学员对开始培训阶段和结束阶段的这段时间记忆会更加深刻。所以在培训开始阶段，培训师也应该避免做过多的客套活动。在结束阶段更应该做更多的帮助学员巩固所学的活动；比如</p>
<ol>
<li>让学员回顾总结所学内容</li>
<li>对学习效果进行评估（柯式四级：</li>
</ol>
<ul>
<li>情绪（感受）：对所学内容感受如何</li>
<li>知识（信息）：记住来哪些学过的知识</li>
<li>行为（技能）：能应用所学的知识嘛</li>
<li>投资回报：公司能从大家所学的东西里获得什么</li>
</ul>
<ol start="3">
<li>帮助学员制定后续计划</li>
<li>庆祝完成学习</li>
</ol>
<p><strong>总结的小练习</strong></p>
<ol>
<li>每个人在一张空白纸上写上一个问题</li>
<li>每个人把纸片传递给右边的人，右边的人把问题的答案写在纸上</li>
<li>然后接着把知传给右边的人，下一个人接着写出答案</li>
<li>直到所有的人都把别人的答案回答一遍</li>
<li>每个人收到最开始递出去的那张纸时，把上面写出来的所有答案读出来，并对收到的答案进行总结</li>
<li>鼓励大家把总结的内容分享给大家</li>
</ol>
<p><strong>庆祝的活动</strong></p>
<ol>
<li>让大家站起来，2到3人一组</li>
<li>让大家站起来沿着教室四处走动，轮流讲一讲培训中的收获，哪些乐趣，学到了哪些内容对自己有意义的东西以及如何学以致用</li>
</ol>
<p>背景音乐，营造气氛...</p>
<h2 id="四-优化课程成精品">四 优化课程成精品</h2>
<h3 id="美化ppt">✨美化PPT</h3>
<ol>
<li>标题</li>
</ol>
<ul>
<li>页面内容的概括</li>
<li>页面论据的论点</li>
</ul>
<ol start="2">
<li>内容短小精悍（拆、删、凸）</li>
<li>图文清晰</li>
</ol>
<p>在备注栏写上必要的信息方便后续他人理解。</p>
<h3 id="讲师手册">✨讲师手册</h3>
<ol>
<li>功能</li>
</ol>
<ul>
<li>介绍课程概要</li>
<li>记录讲授要点（每页PPT的教学目标、讲授方式等）</li>
<li>优化完善课程（改善点）</li>
</ul>
<ol start="2">
<li>编写</li>
</ol>
<ul>
<li>课程背景（SCQA法）</li>
<li>课程简介（名称、对象、时长、人数、授课方式、课程目标）</li>
<li>课程大纲</li>
<li>授课计划（	呈现说明内容和如何呈现两部分）</li>
<li>实施要求</li>
<li>其它（附录、注意事项）</li>
</ul>
<p>###✨ 学员手册（课前学习&amp;课后应用）</p>
<ol>
<li>功能</li>
</ol>
<ul>
<li>了解课程内容</li>
<li>引导课堂学习</li>
<li>展示练习内容</li>
<li>推进课后练习</li>
</ul>
<ol start="2">
<li>编写</li>
</ol>
<ul>
<li>课程背景</li>
<li>课程简介</li>
<li>课程内容
<ol>
<li>帮助学员理解不同内容之间的关系</li>
<li>可以把ppt导出PDF附上</li>
<li>学员接受信息的速度比讲师讲课速度快3-7倍</li>
</ol>
</li>
<li>课堂练习</li>
<li>附录</li>
</ul>
<h2 id="五-反馈闭环">五 反馈闭环</h2>
<hr>
<p><img src="https://upload-images.jianshu.io/upload_images/3126293-9f9a66cf3c07af4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="反馈闭环"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[server 语义化版本规范]]></title>
        <id>https://aceysx.github.io/post/server-yu-yi-hua-ban-ben-gui-fan</id>
        <link href="https://aceysx.github.io/post/server-yu-yi-hua-ban-ben-gui-fan">
        </link>
        <updated>2019-09-02T04:31:46.000Z</updated>
        <content type="html"><![CDATA[<h2 id="semver-简介">semver 简介</h2>
<p>semver 是 <a href="http://semver.org/lang/zh-CN/">语义化版本（Semantic Versioning）规范</a> 的一个实现，目前是由 npm 的团队维护，实现了版本和版本范围的解析、计算、比较。</p>
<h2 id="semver-的两个概念">semver 的两个概念</h2>
<ul>
<li>固定版本：是指例如 0.4.1、1.2.7、1.2.4-beta.0 这样表示包的特定版本的字符串。</li>
<li>范围版本：是对满足特定规则的版本的一种表示，例如 1.2.3-2.3.4、1.x、^0.2、&gt;1.4.</li>
</ul>
<h2 id="版本号格式">版本号格式</h2>
<p>主版本号[MAJOR].次版本号[MINOR].修订号[PATCH]，版本号递增规则如下：</p>
<ol>
<li>主版本号：当做了不兼容的 API 修改，</li>
<li>次版本号：当做了向下兼容的功能性新增，</li>
<li>修订号：当做了向下兼容的问题修正。</li>
</ol>
<p>先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</p>
<blockquote>
<p>当主版本号升级后，次版本号和修订号需要重置为0，次版本号进行升级后，修订版本需要重置为0。</p>
</blockquote>
<p><strong>先行版本号（Pre-release Version）</strong></p>
<p>先行版本号可以作为发布正式版之前的版本，格式是在修订版本号后面加上一个连接号（-），再加上一连串以点（.）分割的标识符，标识符可以由英文、数字和连接号（[0-9A-Za-z-]）组成。example：</p>
<pre><code>1.0​​.0-alpha
1.0.0-alpha.1
1.0.0-0.3.7
1.0.0-x.7.z.92
</code></pre>
<p>以下是一些常见的先行版本号名称：</p>
<ul>
<li>alpha：是内部测试版,一般不向外部发布,会有很多Bug.一般只有测试人员使用。</li>
<li>beta：也是测试版，这个阶段的版本会一直加入新的功能。在Alpha版之后推出</li>
<li>rc：Release　Candidate)  系统平台上就是发行候选版本。RC版不会再加入新的功能了，主要着重于除错。</li>
</ul>
<h2 id="定义依赖版本号">定义依赖版本号</h2>
<p>在 <a href="https://npmjs.com/">npm</a> 的依赖的规则中，还有 <code>~</code>、<code>&gt;</code>、<code>&lt;</code>、<code>=</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>-</code>、<code>||</code>、<code>x</code>、<code>X</code>、<code>*</code> 等符号；当使用 <code>npm install XX</code> 时，被安装的依赖的版本号前会默认加上 <code>^</code> 符号。</p>
<ul>
<li><code>^</code> ：表示同一主版本号中，不小于指定版本号的版本号</li>
</ul>
<pre><code> `^2.2.1` 对应主版本号为 2，不小于 `2.2.1` 的版本号，比如 `2.2.1`、`2.2.2`、`2.3.0` ,主版本号固定
// 当该依赖有最新版本时(eg:2.3.3)，npm install 会安装最新的依赖
</code></pre>
<ul>
<li><code>~</code> ：表示同一主版本号和次版本号中，不小于指定版本号的版本号</li>
</ul>
<pre><code> `~2.2.1` 对应主版本号为 2，次版本号为 2，不小于 `2.2.1` 的版本号，比如 `2.2.1、2.2.2`，主版本号和次版本号固定
</code></pre>
<ul>
<li><code>&gt;</code>、<code>&lt;</code>、<code>=</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>-</code>：用来指定一个版本号范围</li>
</ul>
<pre><code> `&gt;2.1`
 `1.0.0 - 1.2.0`
//注意使用 `-` 的时候，必须两边都有空格。
</code></pre>
<ul>
<li><code>||</code>：表示或</li>
</ul>
<pre><code> `^2 &lt;2.2 || &gt; 2.3`
</code></pre>
<ul>
<li><code>x</code>、<code>X</code>、<code>*</code>：表示通配符</li>
</ul>
<pre><code> `*` 对应所有版本号
 `3.x` 对应所有主版本号为 3 的版本号
</code></pre>
<h2 id="npm-中-package-lockjson-的一些坑">npm 中 package-lock.json 的一些坑</h2>
<p>在 npm install 后，会生成一个 package-lock.json 文件用于保存当前安装依赖的各种来源及版本号。</p>
<p>在 npm 5.4.2版本后，package-lock.json 的变动规则：</p>
<ul>
<li>当在 install dependency 的指定版本时，会自动更新 package-lock.json 文件中该 dependency 的 version 到指定的 version</li>
<li>当在 install dependency 的范围版本时，当前的 version 低于or等于 package-lock.json 文件中对应的 dependency 的 version 时，会安装 package-lock.json 中的 version；</li>
</ul>
<pre><code>package.json
&quot;antd&quot;: &quot;^3.6.1&quot;, // eg：最新版本是 3.9.4

package-lock.json
&quot;antd&quot;: &quot;3.7.1&quot;,

执行npm install 会安装 3.7.1 版本
</code></pre>
<p>如果高于 package-lock.json 中对应的 dependency 的 version 时，会安装当前范围版本号中最高的版本，会更新 package-lock.json 文件中对应的版本号；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[主题阅读]]></title>
        <id>https://aceysx.github.io/post/zhu-ti-yue-du</id>
        <link href="https://aceysx.github.io/post/zhu-ti-yue-du">
        </link>
        <updated>2019-09-02T04:29:30.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>声明：功利阅读的目的并不是沉浸阅读本身，而是吸收知识，快速实践所学知识。所以比较适用于致用类的书籍</p>
</blockquote>
<h2 id="一-什么是功利阅读">一 什么是功利阅读</h2>
<p><strong>功利阅读</strong>是一种阅读书籍的方式，它具有目的性、快速以及按需阅读的特点。也就是说我们需要在很短的时间内，有目的性的阅读一本书的重要内容。</p>
<p>阅读的目的一般分为两种，一种是纯粹为了娱乐消遣时间；另一种是为了从书中获取到有用的知识。事实上从小学到高中，在这以教师为中心的教育体系下，我们阅读的目的大多都是第二种，只是我们更多的可能是被动的获取知识，而非是我们自发的去阅读。一旦到了大学或是在社会上，我们的角色和责任也将转变，没有了以教师为中心的教学方式，由于长期的依赖教师， 我们很难转变到以学习者为中心的学习环境下，从而造成我们很难养成终身学习的能力，而一旦我们没有这种能力，就会愈发的感受到学习难、读书难。</p>
<h2 id="二-为什么要功利阅读">二 为什么要功利阅读</h2>
<p>唯有不断的学习才能改变我们的命运。随着信息量的指数级别增长，知识的更新速度也达到了三年之短，也就是说如果三年没有学习，那么你就已经被社会所淘汰了。在这种情况下，我们的学习时间也并不充足，虽然我们获取信息的渠道非常多，速度也非常快，但是我们很难去甄别哪些信息是对我们有用的。所以为了在不被知识所淹没的情况下快速定位到我们需要的知识，我们必须要有目的的去寻找去阅读我们所需要的知识。</p>
<h2 id="三-阅读的几个关键点">三 阅读的几个关键点</h2>
<ol>
<li>就是因为没有读书，所以没有时间</li>
<li>告诉自己书是我们的仆人，我们不一定要完整的看完一本书，不要觉得没能看完一本书会对不起作者或者自己，因为在书中学到的任何一点内容，只要我们在生活中用到了都是赚的。</li>
<li>28原则，舍弃完美主义，不需要每一段话都理解</li>
<li>一本书的重点只有 20%<br>
<img src="https://upload-images.jianshu.io/upload_images/3126293-3921210afd439740.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20%"></li>
</ol>
<h2 id="四-步骤">四 步骤</h2>
<ol>
<li>准备阶段</li>
</ol>
<ul>
<li>在开始阅读之前，我们先在笔记本上写下自己阅读该书的目的，要想从书中得到什么？可以多条</li>
<li>调查文章：快速阅读 书名、目录、副标题、封面或封底所写的字、著作日期、第一页和最后一页、标题和摘要结论，目的是为了对本书有一个大致对了解。<strong>然后在纸上进一步对完善自己对阅读目的</strong></li>
</ul>
<ol start="2">
<li>超阅读</li>
</ol>
<ul>
<li>整个阅读过程需要我们保持精力集中，速读+跳读的方式快速阅读</li>
<li>阅读过程中遇到与我们的阅读目的相关的地方减缓速读，并在笔记本上记录下来。</li>
<li>阅读过程中遇到比较有意思、难理解的地方也放慢速度，将作者的观点先记录在笔记本上</li>
</ul>
<ol start="3">
<li>总结</li>
</ol>
<ul>
<li>将整个过程中与阅读目的相关的问题及答案归纳到思维导图上（也可以最开始就直接用思维导图）</li>
<li>思考记录下来的作者的观点，回顾自己的经历进行对比，辩证的去看待作者的观点并总结。</li>
</ul>
<ol start="4">
<li>实践</li>
</ol>
<ul>
<li>和朋友聊天时可以讨论分享相关话题</li>
<li>如果在总结中有产出 action，  那么将 action 写下来放在一个显眼的地方提示自己</li>
</ul>
<h2 id="五-阅读方法">五 阅读方法</h2>
<h3 id="1-主题阅读">1 主题阅读</h3>
<p><strong>第一步：</strong> 确定自己想要阅读的主题，提出相关的问题（列出提纲）<br>
<strong>第二步：</strong> 收集书籍清单</p>
<ul>
<li>途径：知乎、豆瓣、亚马逊</li>
<li>步骤：按主题、大家都在读相关、按趋势、按直觉</li>
<li>标准：
<ul>
<li>226 法则：<br>
两本鼻祖书：需要精读（分析阅读），搭建比较完整的知识体系<br>
两本经典书籍：需要精读（分析阅读），进一步充实知识体系<br>
六本入门书：跳读（检视阅读），完善知识体系下的具体章节内容</li>
</ul>
</li>
</ul>
<p><strong>第三步：</strong> 产出思维导图和总结</p>
<h3 id="2-吉尼斯三段火箭法-快速阅读专业书">2 吉尼斯三段火箭法 - 快速阅读专业书</h3>
<p><strong>第一步：</strong> 预览，调查文章（5 mins）<br>
<strong>第二步：</strong> 跳读，根据第一步的结果选择性的阅读 ，标注（15 mins）<br>
<strong>第三步：</strong> 记忆学习，彻底理解在第二步标注的内容，并转换成自己的语言</p>
<h3 id="3-拆书帮便签读书法">3 拆书帮便签读书法</h3>
<p>可以从书中的某个场景入手，快速学习并应用到实践中。<br>
<strong>第一步</strong>：用较快的速读阅读<br>
<strong>第二步</strong>：遇到核心、难理解的部分判断对自己是否有用<br>
<strong>第三步</strong>：如果有用，拿一张便签纸用自己的话叙述、启发<br>
<strong>第四步</strong>：回顾自己的经历，那另外一张便签纸记录<br>
<strong>第五步</strong>：结合自己所读，设想以后遇到类似的情况自己应该怎么处理，记录在另外一张（A3）便签纸上<br>
<strong>第六步</strong>：把 A3 这张便签纸放在显眼的地方提示自己</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[持续交付]]></title>
        <id>https://aceysx.github.io/post/chi-xu-jiao-fu</id>
        <link href="https://aceysx.github.io/post/chi-xu-jiao-fu">
        </link>
        <updated>2019-09-02T04:23:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-软件交付所存在的问题">一 软件交付所存在的问题</h2>
<p><strong>反模式</strong></p>
<p>对于传统IT公司来说，他们的部署方式大多都是使用手工部署，交付周期很长，大多会在实现一个非常大的 feature 才会进行部署，这样便会引发一系列的问题，比如手工部署会过多的依赖部署文档，环境复杂可能需要“部署专家”，部署周期间隔长则会导致反馈周期过长，不能及时的应对需求的变化。这被持续交付称之为软件交付的反模式。</p>
<p><strong>如何避免这些反模式</strong></p>
<p>为了避免以上所说的反模式，我们应该采取一些手段来降低部署/发布的风险：</p>
<ul>
<li>把尽可能多的东西都纳入到版本控制中，对这些进行版本控制，从而可以随时变更发布所需版本</li>
<li>频繁发布</li>
<li>及时反馈，且作出相应的行动</li>
<li>自动化部署流水线</li>
</ul>
<p><strong>持续交付所推崇的交付原则</strong></p>
<ol>
<li>将所有事情自动化</li>
</ol>
<ul>
<li>部署流程，一旦我们有了自动化部署环境，那么我们就可以摆脱手工部署所带来的一切困扰，并且可以进行频繁的部署/发布</li>
<li>验收测试</li>
<li>数据库升级</li>
<li>...</li>
</ul>
<ol start="2">
<li>把所有东西纳入版本控制</li>
</ol>
<ul>
<li>它们可能是源代码，环境配置，数据库数据/配置，网络配置，构建脚本，文档等，从而确保所有的开发人员使用的是同一代码和配置，也最大力度的使得不同的服务器环境保持一致，除此之外，一旦部署失败，我们可以快速的切换到上一个可用的版本进行部署</li>
</ul>
<ol start="3">
<li>内建质量</li>
</ol>
<ul>
<li>软件的质量应该是由整个团结进行负责，不应该只是由QA来负责，越早发现缺陷，修复它的成本就会越低，在开发阶段，测试阶段发现问题要好过于客户发现问题</li>
</ul>
<ol start="4">
<li>DONE 意味着已发布</li>
</ol>
<ul>
<li>DONE 是敏捷看板中的一个story（小功能，包含需求，价值，AC验收条件）从分析到发布上线，当一个 story 的状态被置为 DONE 后，则说明这个 story 已经完成并被部署上线</li>
</ul>
<ol start="5">
<li>持续改进</li>
</ol>
<ul>
<li>retro 在每一次迭代结束或者在工作过程中团队的状态不太好，都可以进行retreo回顾最近一段时间的状况，并根据大家所提出的 feedback 提取出 action 去执行</li>
<li>PDCA 可以适用与任何敏捷方法中，比如 standup，pair，inception，retro... 可以很好的对它们的流程/质量进行改善</li>
</ul>
<h2 id="二-测试策略">二 测试策略</h2>
<p><strong>测试四象限</strong><br>
<img src="https://upload-images.jianshu.io/upload_images/3126293-b1538229e664ed1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="四象限"></p>
<p>其中：</p>
<ul>
<li>业务导向支持开发过程属于是端到端的测试<br>
这种测试往往需要模拟用户的行为，从UI界面到后端的业务的实现整个流程。功能验收测试一般维护成本很大，而且测试也需要很长的时间，位于测试金字塔的顶端，所以这类测试应该尽可能的少写，一般会选择实现 happy path 即可。</li>
<li>业务导向评判项目<br>
一般是向客户演示软件的功能，进行易用性以及探索性的的测试，从而发现更优的一些需求</li>
<li>技术导向支持开发过程<br>
对于单元测试，由于不需要连接数据库，所以测试的速度会非常快，所以单元测试要去覆盖尽可能多的情况，集成测试需要连接数据库，一般会使用内存数据库，速度会慢与单元测试，但会快于功能性测试，位于测试金字塔的中层。单元测试和集成测试是以开发的角度来验证开发人员实现的代码的正确性，而非验证整个story的功能。</li>
</ul>
<p><strong>测试替身</strong></p>
<p>对于单元测试或者在进行集成测试的时候需要调用第三方，那么就需要用到测试替身来模拟。测试替身有以下几种类型</p>
<ul>
<li>dummy object ： 致那些被传递但是不被真正使用的对象，一般用于参数列表</li>
<li>fake object：是可以真正使用的对象，通常会使用一些捷径，不适合在 prod 上使用，比如内存数据库</li>
<li>stub：在测试中为每个调用提供一个封装好的响应，不会对测试之外对请求进行响应，只用于测试</li>
<li>spy：记录一些关于如何被调用对信息对桩</li>
<li>mock object： 在编程时就设定了它预期要接收的调用和返回的结果</li>
</ul>
<h2 id="三-持续集成">三 持续集成</h2>
<p>当团队有多人一起进行协作开发时，频繁的提交代码到版本库中进行合并是非常重要的，这可以最大限度的防止代码冲突的发生以及降低解决冲突的成本，并且可以让代码库的代码保持最新且可以work</p>
<p><strong>实现持续集成的准备工作</strong></p>
<ul>
<li>版本控制</li>
<li>自动化构建环境</li>
<li>团队的共识，非常重要，团队中的每个人都必须遵守这一实践</li>
</ul>
<p><strong>集成步骤</strong></p>
<ol>
<li>提交代码时，先查看是否有构建正在运行，如果有先等他构建完，如果失败了，需要和组员一起修复它，然后提交自己的代码</li>
<li>一旦构建完成且测试通过，就将最新代码更新到自己到开发环境上</li>
<li>如果本地构建成功，就将代码提交到版本库中</li>
<li>如果构建失败，就停下手中的事，在本机上立即修复这个问题，然后构建</li>
<li>如果这次构建成功的话，就可以开始下一项任务</li>
</ol>
<p><strong>前提条件</strong></p>
<ul>
<li>频繁提交</li>
<li>自动化测试套件（单元测试，集成测试，验收测试），如果没有测试，那么即使构建也无法验证所提交的代码是否可以work</li>
</ul>
<p><strong>最佳实践</strong></p>
<ul>
<li>构建失败后不要提交代码</li>
<li>提交代码前在本地运行测试或让集成服务器去跑测试</li>
<li>等提交测试通过在继续工作</li>
<li>回家之前构建必须是处于成功状态（如果失败，修复失败的构建or回滚到上一个可以work的代码进行构建）</li>
<li>时刻准备着回滚到上一个版本</li>
<li>在回滚之前要规定一个修复时间，在这个时间内，其他人不能提交代码，如果在这个时间段内没有修复好，那么回滚</li>
<li>不要将失败的测试注释掉，避免回归测试，如果业务发生改变应该修改测试，如果这个功能不存在则可以删除该测试</li>
</ul>
<h2 id="四-部署流水线">四 部署流水线</h2>
<p>部署流水线是持续交付的核心，指软件从版本库到用户手中何以过程的自动化表现形式。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3126293-573c3211d101006b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基本的部署流水线"></p>
<p>其中：</p>
<ol>
<li>提交阶段<br>
通过自动化的编译，测试，打包，从而将二进制文件放入到制品库中，为后续的流程作准备。如果编译/测试出错，开发人员可以看到详细的错误的原因并快速修复。</li>
<li>验收阶段<br>
从制品库中拿到提交阶段的输出（二进制文件）进行部署、冒烟测试以及验收测试，这一过程是针对业务的功能测试，而非针对开发。</li>
<li>手工测试阶段<br>
对系统进行一些易用性，探索性，UAT测试</li>
<li>发布阶段<br>
前面一系列的步骤都是为了发布作准备，从而将可以work的软件交付给客户。理想情况下，我们已经在前面的步骤已经确保了软件各方面的正确性，可以正确的发布，但实际情况下，我们难免会遇到一些bug导致发布失败，面对这一情况，我们就需要做到快速的修复或者使用一些方式做到即使发布失败也不会影响到正常的运行</li>
</ol>
<ul>
<li>版本回退<br>
在发布失败后，最常见的解决方法就是版本回退，不过这会导致一段时间内软件不可使用</li>
<li>蓝绿部署<br>
<img src="https://upload-images.jianshu.io/upload_images/3126293-449744d81ba34b99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="蓝绿部署"></li>
</ul>
<p><strong>要点</strong>：修改路由，将用户导向不同的环境<br>
<strong>对数据的处理</strong>：<br>
1.在部署到蓝环境（待部署的环境）前，将绿环境（正常环境）DB设置为onlyread状态，并备份<br>
2.迁移备份到蓝环境<br>
3.切换路由到蓝环境，如果一切正常将蓝环境DB设置为读写<br>
4.如果蓝环境正常，部署绿环境，将路由再切换回绿环境，备份蓝环境数据到绿环境<br>
**影子城发布：**部署两个相同的环境，成本可能会比较高，一个替代方案就是将试运行环境和生产环境作为蓝绿环境</p>
<ul>
<li>金丝雀发布（A/B test）</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3126293-89fc73cfecf8e049.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="金丝雀发布"></p>
<p>关键点也是通过路由将用户到向不同到服务器中，与蓝绿部署不同的在于，金丝雀发布会将不同的版本放在不同的服务器（集群）中，然后将部分用户导向到新的版本，这不仅适用于测试新版本到功能是否可用，也同时可以用来测试新功能到使用情况，从而决定是否需要这个功能。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[金字塔原理]]></title>
        <id>https://aceysx.github.io/post/jin-zi-ta-yuan-li</id>
        <link href="https://aceysx.github.io/post/jin-zi-ta-yuan-li">
        </link>
        <updated>2019-09-02T04:19:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="开始之前">开始之前</h2>
<p>在开始之前，先来回想一下。从会思考，写作开始一直到现在，我们每一次思考，写作的依据是什么呢？或者说流程是什么呢，我们有自己的思考写作框架嘛？大多数人可能都没有意识到这个问题，属于佛系写作，思考，想到哪表达到哪，这也就导致了平时写出来的东西，结构总是很乱，很难被人理解；和人沟通表达出来的讯息也总是让人抓不住要点。</p>
<p>那么一旦有了一个框架并按照这个框架去写作/思考，那么会有什么不同呢？还记得在高中时，每次写作文，最常用的总分总结构吗？老师总能get到作文的要点是什么，不管我们写的多么的混乱。</p>
<p>这就是养成对一件事使用固有的框架后可以带来的好处，在做这件事时不断的使用该框架并 review，让自己更加熟练的应用，高效的完成想要做的。而金字塔就是这样的一个框架，可以帮助我们写作，思考。</p>
<h2 id="一-什么是金字塔结构">一 什么是金字塔结构</h2>
<p>先上图<br>
<img src="https://upload-images.jianshu.io/upload_images/3126293-ef738ee02f5bad35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="金字塔结构"></p>
<p>和我们传统的金字塔还是有所不同的，图中金字塔的每一层都都是有1到n个块组成，每一个块都被称为是一个“思想”，即向读者发出新信息并引起读者疑问的句子。比如：金字塔结构是一个思考框架，那么向读者传达的信息就是<strong>金字塔结构是一个思考框架</strong>，也会引起读者的疑问<strong>为什么金字塔结构是一个思考框架</strong>。</p>
<p>金字塔思想则是从金字塔的顶端开始，沿着各个分支向下展开，首先表达的中心思想将使读者对作者这样的表述产生某种疑问，而中心思想的（金字塔结构中的）下一层上的思想则是对此问题的回答，通过不断的进行疑问/回答式的对话，读者就可以了解文章中的所有思想。</p>
<h2 id="二-具有金字塔结构的思想">二 具有金字塔结构的思想</h2>
<h4 id="1-组织关系">1. 组织关系</h4>
<p>在整个金字塔结构中，可分为 <strong>纵向</strong> 和 <strong>横向</strong> 两种关系，其中每一层中的思想是一个横向关系，每一层之间则是属于纵向关系。</p>
<h5 id="纵向关系"><strong>纵向</strong>关系：</h5>
<p>每一层中的每一思想都必须是下一层次所包含的思想的概括，上一层次的思想会引起读者的疑问，而下一层次的思想则是对这一疑问的回答。</p>
<h5 id="横向关系"><strong>横向</strong>关系：</h5>
<p>每一层中的一组思想可以是属于统一范涛的思想抽象归纳成一个上层思想，也可以是通过某种逻辑顺序演绎成一个上层思想。<br>
其中<strong>抽象归纳</strong>需要我们观察发现将具有某种相同结构的思想归纳到一起，抽象成一个思想。比如：<br>
<img src="https://upload-images.jianshu.io/upload_images/3126293-f7e4c776d69dec92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="归纳推理"><br>
其中逻辑顺序则包含了 演绎顺序，时间顺序，结构顺序（SECE：相互独立，完全穷尽），重要性顺序，可以通过不同的逻辑顺序最终推理出上一层的思想。</p>
<h4 id="2-思考顺序">2 思考顺序</h4>
<p>在了解了组织关系后，现在可以考虑该从哪开始入手，是选择从上至下构建金字塔结构还是从下至上？</p>
<h5 id="从上至下">从上至下</h5>
<p>如果我们知道想要表达的中心思想是什么，那么便可以快速的构建出金字塔。</p>
<ol>
<li>画出顶层主题方框，写入<strong>中心思想</strong></li>
<li>在顶层的下一层确定主要的几个问题</li>
<li>接着在下一层回答上一层提出的问题，采用归纳和逻辑顺序的方式</li>
<li>如果上一层的答案非常的接地气（可以很容易让读者理解，且不会让读者产生新的问题），那么金字塔就已经构建完毕。否则需要进一步针对可能产生的新问题构建下一层并进行回答，直到不会产生新的问题为止。<br>
<img src="https://upload-images.jianshu.io/upload_images/3126293-c8f0cc098e5f8431.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="从上至下"></li>
</ol>
<h4 id="从下至上">从下至上</h4>
<p>如果我们还没找到一个中心思想，那么只能选择从下至上的方法</p>
<ol>
<li>列出所要表达的所有思想（问题和解决方案）</li>
<li>找出各个要点之间的关系（可能是一组相同范涛的思想，可以使用归纳抽象；也可能是某种逻辑关系）</li>
<li>得出结论，不断的抽象推理出上层思想</li>
</ol>
<h2 id="三-写作思考的逻辑">三 写作/思考的逻辑</h2>
<p>当我们可以将自己想要表达的思想构建成金字塔结构，即通过疑问/回答的方式将思想传达给读者。<br>
在写作时，同样可以应用该结构，需要做的一点是如何将读者引导到金字塔的主要问题上来，即该如何吸引读者有兴趣进入到第一层思想。一个很好的方式是给文章写一个序言，序言的作用是承上启下，起一个过渡作用，让读者产生悬念，吸引读者。</p>
<h4 id="序言的写法scqa">序言的写法：SCQA</h4>
<p>通过讲故事的方式来引起读者的兴趣。</p>
<p><strong>S</strong>ituation：对该中心思想的背景进行描述</p>
<p><strong>C</strong>omplication：在描述的过程中会发现目前的状态和期望的结果存在差异性，从而会产生冲突</p>
<p><strong>Q</strong>uestion：有了冲突，那么就会产生问题（引导到金字塔结构）</p>
<p><strong>A</strong>nswer：使用构建好的金字塔结构进行回答</p>
<h2 id="四-解决问题的逻辑">四 解决问题的逻辑</h2>
<hr>
<p>该方式适用的场景侧重于在做研究报告/ppt（通常用来给出解决方案）或者是写项目建议书/咨询报告（给出如果解决问题的过程）这种需要经过大量的前期调研过程。通过该方式可以回答以下几个问题：<br>
1⃣️有没有/可不可能有问题？<br>
2⃣️它在哪里？<br>
3⃣️我们能做什么？<br>
4⃣️我们应该做什么？</p>
<p>解决问题的逻辑的流程：</p>
<p><strong>1 界定问题</strong><br>
首先可以通过一个问题来判断是否真的存在问题，经过某种努力后得到的结果和预期的结果之间是否有差距？如果经过努力后现实和理想的结果之间差距越来越小，那么就可以判定当下是存在问题的。那么就下来就可以尝试去确定问题是什么？<br>
1⃣️发生了什么事情（Situation 是什么）<br>
2⃣️ 我们不喜欢它什么（非期望的结果R1）<br>
3⃣️ 我们想要的是什么（期望的结果R2）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3126293-4178acad1bede821.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="example"></p>
<p><strong>2 结构性分析问题</strong><br>
1⃣️对界定出来的问题提出假设<br>
2⃣️设计一项or多项试验，排除部分假设<br>
3⃣️通过假设得出结论<br>
4⃣️提出方案</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3126293-d3416692115c5148.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="example"></p>
<p><strong>3 构建金字塔</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[「OpenJdk-11 源码-系列」 Object]]></title>
        <id>https://aceysx.github.io/post/openjkd-11-yuan-ma-object</id>
        <link href="https://aceysx.github.io/post/openjkd-11-yuan-ma-object">
        </link>
        <updated>2019-08-30T06:38:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="object">Object</h2>
<hr>
<p>在 Java 中 <code>Object</code> 类是所有类的祖先类，<code>Object</code> 没有定义属性，一共有13个方法。其它所有的子类都会继承这些方法。</p>
<h2 id="构造函数">构造函数</h2>
<hr>
<h3 id="registernatives">registerNatives()</h3>
<pre><code class="language-java"> private static native void registerNatives();
 static {
        registerNatives();
 }
</code></pre>
<blockquote>
<p>在 Java 中，用 native 关键字修饰的函数表明该方法的实现并不是在Java中去完成，而是由C/C++去完成，并被编译成了.dll，由Java去调用</p>
</blockquote>
<p>而 <code>registerNatives()</code>方法的主要作用则是将C/C++中的方法映射到 Java 中的 <code>native</code>方法，实现方法命名的解耦。</p>
<h3 id="构造函数-public-object">构造函数 public Object()</h3>
<pre><code class="language-java"> @HotSpotIntrinsicCandidate
 public Object() {}
</code></pre>
<blockquote>
<p>@HotSpotIntrinsicCandidate注解，该注解是特定于Java虚拟机的注解。通过该注解表示的方法可能( 但不保证 )通过HotSpot VM自己来写汇编或IR编译器来实现该方法以提供性能。 它表示注释的方法可能（但不能保证）由HotSpot虚拟机内在化。如果HotSpot VM用手写汇编和/或手写编译器IR（编译器本身）替换注释的方法以提高性能，则方法是内在的。 也就是说虽然外面看到的在JDK9中weakCompareAndSet和compareAndSet底层依旧是调用了一样的代码，但是不排除HotSpot VM会手动来实现weakCompareAndSet真正含义的功能的可能性</p>
</blockquote>
<p>一般创建对象的时候直接使用 <code>new className(Args)</code> 来创建一个新的对象。而在类的定义过程中，对于未定义构造函数的类，那么它就会默认继承<code>Object</code>的无参构造函数，如果定了一个或多个构造函数，那么就需要把无参构造函数方法也写上。</p>
<h2 id="方法">方法</h2>
<hr>
<h3 id="public-final-native-class-getclass">public final native Class&lt;?&gt; getClass()</h3>
<pre><code class="language-java"> @HotSpotIntrinsicCandidate
 public final native Class&lt;?&gt; getClass();
</code></pre>
<p><code>getClass</code>返回运行时当前对象的类对象。在 Java 中，类是对具有一组相同特征或行为的实例的抽象进行描述。而<strong>类对象</strong>则是对<strong>类</strong>的特征和行为进行描述（即类的名称，属性，方法...）。也就是说通过获取到类对象，则可以获取到该类的所有属性，方法等。</p>
<h3 id="public-native-int-hashcode">public native int hashCode()</h3>
<pre><code class="language-java">@HotSpotIntrinsicCandidate
public native int hashCode();
</code></pre>
<p><code>hashCode</code> 返回当前对象的哈希码。<code>hashCode</code>遵守以下三个约定</p>
<ul>
<li>在 Java 程序运行期间，对同一个对象多次调用<code>hashCode</code>，那么它们的返回值需要是一致的。（前提：没有对对象进行修改）</li>
<li>如果两个对象相等（调用<code>equals()</code>方法），那么这两个对象的 <code>hashCode</code>也是一样</li>
<li>两个对象调用<code>hashCode</code>方法返回的哈希码相等，这两个对象不一定相等</li>
</ul>
<p>也即是说，调用<code>equals</code>方法返回值相等，那么调用<code>hashCode</code>方法返回值也一定相等。所以，在重写<code>euqlas</code>方法之后，一定要重写<code>hashCode</code>方法。</p>
<p>那么判断对象是否先等可以直接用<code>equals</code>来判断，为什么还需要<code>hashCode</code>方法呢？</p>
<p>其实<code>hashCode</code>方法的一个主要作用是为了增强哈希表的性能。比如：我们知道<code>Set</code>集合不能存在相同的两个对象，那么该怎么判断两个对象是否相同呢？如果没有<code>hashCode</code>，那么就需要进行遍历来逐一判断。那么有<code>hashCode</code>，我们就可以计算出即将要加入集合的对象的<code>hashCode</code>，然后查看集合中对应的位置上是否有对象即可。</p>
<h3 id="public-boolean-equalsobject-obj">public boolean equals(Object obj)</h3>
<pre><code class="language-java">public boolean equals(Object obj) {
   return (this == obj);
}
    
</code></pre>
<p><code>equals()</code>用于判断两个对象是否相等。根据 <code>Object</code>    的实现，可以看到判断的依据是看两个对象的引用地址是否相等。</p>
<p>而一般我们会用另外一种方式来判断是否相等。即<code>==</code>,<code>==</code>表示的是两个变量值是否相等（基础类型的值在内存地址中存储的是值）</p>
<p>那么我们想要判断是否相等：</p>
<ul>
<li>如果是基础类型，就可以直接用<code>==</code>来判断</li>
<li>如果是引用类型，那么就需要通过<code>equals</code>方法来判断（在实际业务中，一般会重写<code>equals</code>方法）</li>
</ul>
<p>需要注意的一点是<code>String</code>也是引用类型，我们判断<code>String</code>的时候是直接使用的<code>equals</code>方法，而按照默认的<code>equals</code>实现，创建两个具有相同值的<code>String</code>对象，那么<code>equals</code>返回的应该是<code>false</code>，</p>
<pre><code class="language-java">public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String aString = (String)anObject;
        if (coder() == aString.coder()) {
            return isLatin1() ? StringLatin1.equals(value, aString.value)
                              : StringUTF16.equals(value, aString.value);
        }
    }
    return false;
}
</code></pre>
<h3 id="public-string-tostring">public String toString()</h3>
<pre><code class="language-java"> public String toString() {  
    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());  
}
</code></pre>
<p><code>toString()</code>返回该对象的字符串表示。在使用 <code>System.out.printLn(obj)</code>的时候，其内部也是调用的<code>toString</code>方法。可以按需重写<code>toString</code>方法。</p>
<h3 id="protected-native-object-clone">protected native Object clone()</h3>
<pre><code class="language-java">protected native Object clone() throws CloneNotSupportedException;
</code></pre>
<p><code>clone()</code>方法返回的是当前对象的引用，指向的是新<code>clone</code>出来的对象，此对象和原对象占用不同的堆空间。</p>
<p><strong><code>clone</code>方法的正确调用需要实现 <code>cloneable</code> 接口，如果没有实现该接口，那么子类调用父类的 <code>clone</code>方法则会抛出<code>CloneNotSupportedException</code>异常</strong></p>
<blockquote>
<p>Cloneable接口仅仅是一个表示接口，接口本身不包含任何方法，用来指示Object.clone()可以合法的被子类引用所调用。</p>
</blockquote>
<h4 id="1-使用">1. 使用</h4>
<p>先看一段代码</p>
<pre><code class="language-java">public class CloneTest {  
  
    public static void main(String[] args) {  
        Object o1 = new Object();  
        try {
            Object clone = o1.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
    }  
  
}  
</code></pre>
<p>执行这段段代码会抛出<code>The method clone() from the type Object is not visible</code>异常。原因是<code>clone</code> 方法是被 <code>protected</code>修饰的，也就是说被<code>protected</code>修饰的属性和方法，<strong>在同一包下或在不同包下的子类可以访问</strong>。显然，<code>CloneTest</code>和<code>Object</code>不在同一包下，不过按照字面意思，<code>CloneTest</code>会默认继承<code>Object</code>，所以即使在不同的包下，应该也是可以访问的才对。那么问题就出现在「在不同包下的子类可以访问」这句话上：</p>
<blockquote>
<p>不同包中的子类可以访问: 是指当两个类不在同一个包中的时候，继承自父类的子类内部且主调（调用者）为子类的引用时才能访问父类用protected修饰的成员（属性/方法）。 在子类内部，主调为父类的引用时并不能访问此protected修饰的成员。（super关键字除外）</p>
</blockquote>
<p>也就是说在子类中想要调用父类的<code>protected</code>方法，可以</p>
<ul>
<li>在子类中重写父类的方法</li>
<li>在子类中通过<code>super.methodName()</code>来调用父类方法</li>
</ul>
<h4 id="2-浅拷贝深拷贝">2. 浅拷贝&amp;深拷贝</h4>
<blockquote>
<p>浅拷贝： 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是引用类型，拷贝的就是内存地址。<br>
深拷贝： 深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。</p>
</blockquote>
<p>对于浅拷贝来说，如果含有引用类型，那么修改其中一个对象的引用值，那么会影响到另外一个对象。按层级来说，浅拷贝只拷贝了第一层。对于默认的<code>clone</code>实现是浅拷贝。如果想要实现深拷贝，可以</p>
<ul>
<li>对对象进行序列化</li>
<li>重写<code>clone</code>方法</li>
</ul>
<pre><code class="language-java">//序列化实现深拷贝

public class CloneUtils {
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T extends Serializable&gt; T clone(T obj){
        T cloneObj = null;
        try {
            //写入字节流
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            ObjectOutputStream obs = new ObjectOutputStream(out);
            obs.writeObject(obj);
            obs.close();
            
            //分配内存，写入原始对象，生成新对象
            ByteArrayInputStream ios = new ByteArrayInputStream(out.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(ios);
            //返回生成的新对象
            cloneObj = (T) ois.readObject();
            ois.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return cloneObj;
    }
}

public class Person implements Serializable{
    private static final long serialVersionUID = 2631590509760908280L;
}

public class CloneTest {
    public static void main(String[] args) {
        Person person =  new Person();
        Person person1 =  CloneUtils.clone(person);     
    }
}


参考：https://blog.csdn.net/chenssy/article/details/12952063
</code></pre>
<h3 id="protected-void-finalize">protected void finalize()</h3>
<pre><code class="language-java">protected void finalize() throws Throwable {}
</code></pre>
<p><code>finalize()</code>方法主要与 Java 垃圾回收机制有关，JVM准备对此对形象所占用的内存空间进行垃圾回收前，将被调用。所以此方法并不是由我们主动去调用的。</p>
<h3 id="waitnotifynotifyall">wait()/notify/notifyAll</h3>
<p>可先看<a href="https://www.jianshu.com/nb/10715227">java 多线程</a>尝鲜。后续会专门讲多线程相关源码。</p>
]]></content>
    </entry>
</feed>